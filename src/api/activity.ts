// src/api/activityApi.ts
/**
 * Production-ready Activity API
 * Optimized for CRM activity feed - primarily read-only operations
 * Activities are automatically generated by the system based on user actions
 */

import {
    apiClientNew,
    PaginatedApiResponse,
    PaginationParams,
    ApiError,
    RequestConfig
} from './apiClientNew';
import {
    ActivityItem,
    ActivityCategory,
    ActivityFilter,
    DailySummaryData,
    EntityType,
    ActivityStatus
} from '../types/activity';

// ========================================================================================
// TYPE DEFINITIONS
// ========================================================================================

/**
 * Activity search and filter parameters
 */
export interface ActivitySearchParams extends PaginationParams {
    category?: ActivityCategory;
    userId?: string;
    entityType?: EntityType;
    entityId?: string;
    status?: ActivityStatus;
    startDate?: string;
    endDate?: string;
    search?: string;
    sortBy?: 'timestamp' | 'category' | 'user';
    sortOrder?: 'asc' | 'desc';
}

/**
 * Activity analytics request
 */
export interface ActivityAnalyticsRequest {
    startDate: string;
    endDate: string;
    groupBy?: 'day' | 'week' | 'month';
    categories?: ActivityCategory[];
    userIds?: string[];
}

/**
 * Activity analytics response
 */
export interface ActivityAnalyticsResponse {
    summary: {
        totalActivities: number;
        categoriesBreakdown: Record<ActivityCategory, number>;
        usersBreakdown: Record<string, number>;
        statusBreakdown: Record<string, number>;
        trendsData: Array<{
            date: string;
            count: number;
            categories: Record<ActivityCategory, number>;
        }>;
    };
    dailySummaries: DailySummaryData[];
    topUsers: Array<{
        userId: string;
        userName: string;
        activityCount: number;
        categories: Record<ActivityCategory, number>;
    }>;
    entityStats: Array<{
        entityType: EntityType;
        entityId: string;
        entityDisplayName: string;
        activityCount: number;
        lastActivity: string;
    }>;
}

/**
 * API operation result
 */
export interface ActivityApiResult<T = any> {
    success: boolean;
    data?: T;
    error?: string;
    details?: any;
}

// ========================================================================================
// ACTIVITY API CLASS
// ========================================================================================

/**
 * Production-ready Activity API focused on read operations and analytics
 * Activities are automatically generated by the system, not manually managed
 */
class ActivityApi {
    private readonly baseEndpoint = '/activities';
    private readonly cacheTimeout = 5 * 60 * 1000; // 5 minutes
    private cache = new Map<string, { data: any; timestamp: number }>();

    // ========================================================================================
    // CORE READ OPERATIONS
    // ========================================================================================

    /**
     * Fetches paginated list of activities with advanced filtering and sorting
     * Primary method for the activity feed
     *
     * @param params - Search, filter, and pagination parameters
     * @returns Promise<ActivityApiResult<PaginatedApiResponse<ActivityItem>>>
     */
    async getActivities(params: ActivitySearchParams = {}): Promise<ActivityApiResult<PaginatedApiResponse<ActivityItem>>> {
        try {
            console.log('üîç Fetching activities with params:', params);

            const {
                page = 0,
                size = 20,
                sortBy = 'timestamp',
                sortOrder = 'desc',
                ...filterParams
            } = params;

            // Build query parameters
            const queryParams = this.buildQueryParams({
                ...filterParams,
                sortBy,
                sortOrder
            });

            // Check cache for historical data (older than today)
            const cacheKey = `activities-${JSON.stringify(params)}`;
            const cachedResult = this.getCachedResult(cacheKey);
            if (cachedResult && !this.includesRecentData(params)) {
                console.log('üìã Returning cached activities');
                return cachedResult;
            }

            // Fetch from API
            const response = await apiClientNew.getWithPagination<ActivityItem>(
                this.baseEndpoint,
                queryParams,
                { page, size },
                {
                    timeout: 15000,
                    retries: 2
                }
            );

            // Process and enhance activity data
            const processedActivities = response.data.map(activity =>
                this.enhanceActivityItem(activity)
            );

            const result: ActivityApiResult<PaginatedApiResponse<ActivityItem>> = {
                success: true,
                data: {
                    ...response,
                    data: processedActivities
                }
            };

            // Cache historical data
            if (!this.includesRecentData(params)) {
                this.setCachedResult(cacheKey, result);
            }

            console.log('‚úÖ Successfully fetched activities:', {
                count: processedActivities.length,
                totalItems: response.pagination.totalItems,
                currentPage: response.pagination.currentPage
            });

            return result;

        } catch (error) {
            console.error('‚ùå Error fetching activities:', error);
            return this.handleApiError(error, 'pobrania aktywno≈õci');
        }
    }

    /**
     * Fetches a single activity by ID with full details
     * Used for activity detail views or deep linking
     *
     * @param activityId - Activity ID
     * @returns Promise<ActivityApiResult<ActivityItem>>
     */
    async getActivityById(activityId: string): Promise<ActivityApiResult<ActivityItem>> {
        try {
            console.log('üîç Fetching activity by ID:', activityId);

            if (!activityId?.trim()) {
                return {
                    success: false,
                    error: 'ID aktywno≈õci jest wymagane'
                };
            }

            const response = await apiClientNew.get<ActivityItem>(
                `${this.baseEndpoint}/${activityId}`,
                undefined,
                { timeout: 10000 }
            );

            const enhancedActivity = this.enhanceActivityItem(response);

            console.log('‚úÖ Successfully fetched activity:', enhancedActivity.id);

            return {
                success: true,
                data: enhancedActivity
            };

        } catch (error) {
            console.error('‚ùå Error fetching activity by ID:', error);
            return this.handleApiError(error, 'pobrania aktywno≈õci');
        }
    }

    // ========================================================================================
    // ANALYTICS AND SUMMARIES
    // ========================================================================================

    /**
     * Gets activity analytics and statistics
     * Used for dashboard widgets and reports
     *
     * @param params - Analytics parameters
     * @returns Promise<ActivityApiResult<ActivityAnalyticsResponse>>
     */
    async getActivityAnalytics(params: ActivityAnalyticsRequest): Promise<ActivityApiResult<ActivityAnalyticsResponse>> {
        try {
            console.log('üìä Fetching activity analytics:', params);

            const queryParams = this.buildQueryParams(params);

            // Cache analytics for historical periods
            const cacheKey = `analytics-${JSON.stringify(params)}`;
            const cachedResult = this.getCachedResult(cacheKey);
            if (cachedResult && !this.isCurrentPeriod(params.startDate, params.endDate)) {
                console.log('üìã Returning cached analytics');
                return cachedResult;
            }

            const response = await apiClientNew.get<ActivityAnalyticsResponse>(
                `${this.baseEndpoint}/analytics`,
                queryParams,
                { timeout: 20000 }
            );

            const result: ActivityApiResult<ActivityAnalyticsResponse> = {
                success: true,
                data: response
            };

            // Cache historical analytics
            if (!this.isCurrentPeriod(params.startDate, params.endDate)) {
                this.setCachedResult(cacheKey, result);
            }

            console.log('‚úÖ Successfully fetched activity analytics');

            return result;

        } catch (error) {
            console.error('‚ùå Error fetching activity analytics:', error);
            return this.handleApiError(error, 'pobrania analityk');
        }
    }

    /**
     * Gets daily summary for a specific date
     * Used for daily statistics in the activity feed
     *
     * @param date - Date in YYYY-MM-DD format
     * @returns Promise<ActivityApiResult<DailySummaryData>>
     */
    async getDailySummary(date: string): Promise<ActivityApiResult<DailySummaryData>> {
        try {
            console.log('üìÖ Fetching daily summary for:', date);

            if (!this.isValidDate(date)) {
                return {
                    success: false,
                    error: 'Nieprawid≈Çowy format daty. Oczekiwany format: YYYY-MM-DD'
                };
            }

            // Cache summaries for past dates
            const cacheKey = `daily-summary-${date}`;
            const isToday = date === new Date().toISOString().split('T')[0];

            if (!isToday) {
                const cachedResult = this.getCachedResult(cacheKey);
                if (cachedResult) {
                    console.log('üìã Returning cached daily summary');
                    return cachedResult;
                }
            }

            const response = await apiClientNew.get<DailySummaryData>(
                `${this.baseEndpoint}/summary/daily`,
                { date },
                { timeout: 12000 }
            );

            const result: ActivityApiResult<DailySummaryData> = {
                success: true,
                data: response
            };

            // Cache past summaries
            if (!isToday) {
                this.setCachedResult(cacheKey, result);
            }

            console.log('‚úÖ Successfully fetched daily summary:', response.date);

            return result;

        } catch (error) {
            console.error('‚ùå Error fetching daily summary:', error);
            return this.handleApiError(error, 'pobrania podsumowania dziennego');
        }
    }

    // ========================================================================================
    // ENTITY-RELATED OPERATIONS
    // ========================================================================================

    /**
     * Gets activities related to a specific entity
     * Used for entity detail pages (client, vehicle, appointment history)
     *
     * @param entityType - Type of entity
     * @param entityId - Entity ID
     * @param params - Additional parameters
     * @returns Promise<ActivityApiResult<ActivityItem[]>>
     */
    async getActivitiesByEntity(
        entityType: EntityType,
        entityId: string,
        params: Omit<ActivitySearchParams, 'entityType' | 'entityId'> = {}
    ): Promise<ActivityApiResult<ActivityItem[]>> {
        try {
            console.log('üîó Fetching activities for entity:', entityType, entityId);

            if (!entityType || !entityId?.trim()) {
                return {
                    success: false,
                    error: 'Typ encji i ID sƒÖ wymagane'
                };
            }

            const queryParams = this.buildQueryParams({
                ...params,
                entityType,
                entityId,
                sortBy: 'timestamp',
                sortOrder: 'desc'
            });

            const response = await apiClientNew.get<ActivityItem[]>(
                `${this.baseEndpoint}/entity`,
                queryParams,
                { timeout: 15000 }
            );

            const enhancedActivities = response.map(activity =>
                this.enhanceActivityItem(activity)
            );

            console.log('‚úÖ Successfully fetched entity activities:', enhancedActivities.length);

            return {
                success: true,
                data: enhancedActivities
            };

        } catch (error) {
            console.error('‚ùå Error fetching entity activities:', error);
            return this.handleApiError(error, 'pobrania aktywno≈õci encji');
        }
    }

    // ========================================================================================
    // CONVENIENCE METHODS
    // ========================================================================================

    /**
     * Gets recent activities (optimized for dashboard)
     *
     * @param limit - Maximum number of activities
     * @returns Promise<ActivityApiResult<ActivityItem[]>>
     */
    async getRecentActivities(limit: number = 50): Promise<ActivityApiResult<ActivityItem[]>> {
        const today = new Date();
        const sevenDaysAgo = new Date(today);
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const result = await this.getActivities({
            startDate: sevenDaysAgo.toISOString().split('T')[0],
            endDate: today.toISOString().split('T')[0],
            size: limit,
            sortBy: 'timestamp',
            sortOrder: 'desc'
        });

        return {
            success: result.success,
            data: result.data?.data,
            error: result.error,
            details: result.details
        };
    }

    /**
     * Gets activities for date range (used by ActivityFeedPage)
     *
     * @param startDate - Start date (YYYY-MM-DD)
     * @param endDate - End date (YYYY-MM-DD)
     * @param filters - Additional filters
     * @returns Promise<ActivityApiResult<ActivityItem[]>>
     */
    async getActivitiesForDateRange(
        startDate: string,
        endDate: string,
        filters: Omit<ActivitySearchParams, 'startDate' | 'endDate'> = {}
    ): Promise<ActivityApiResult<ActivityItem[]>> {
        console.log('üìÖ Fetching activities for date range:', startDate, 'to', endDate);

        const result = await this.getActivities({
            ...filters,
            startDate,
            endDate,
            size: 1000, // Large limit for date range queries
            sortBy: 'timestamp',
            sortOrder: 'desc'
        });

        return {
            success: result.success,
            data: result.data?.data,
            error: result.error,
            details: result.details
        };
    }

    /**
     * Exports activities to various formats
     *
     * @param params - Export parameters
     * @param format - Export format
     * @returns Promise<ActivityApiResult<Blob>>
     */
    async exportActivities(
        params: ActivitySearchParams,
        format: 'csv' | 'xlsx' | 'pdf' = 'csv'
    ): Promise<ActivityApiResult<Blob>> {
        try {
            console.log('üì§ Exporting activities:', format);

            const queryParams = this.buildQueryParams({
                ...params,
                format
            });

            const response = await fetch(
                `${apiClientNew['baseUrl']}${this.baseEndpoint}/export?${new URLSearchParams(queryParams)}`,
                {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('auth_token')}`,
                        'Accept': 'application/octet-stream'
                    }
                }
            );

            if (!response.ok) {
                throw new ApiError(response.status, response.statusText);
            }

            const blob = await response.blob();

            console.log('‚úÖ Successfully exported activities');

            return {
                success: true,
                data: blob
            };

        } catch (error) {
            console.error('‚ùå Error exporting activities:', error);
            return this.handleApiError(error, 'eksportu aktywno≈õci');
        }
    }

    // ========================================================================================
    // PRIVATE HELPER METHODS
    // ========================================================================================

    /**
     * Builds query parameters for API requests
     */
    private buildQueryParams(params: Record<string, any>): Record<string, any> {
        const queryParams: Record<string, any> = {};

        Object.entries(params).forEach(([key, value]) => {
            if (value !== undefined && value !== null && value !== '') {
                if (Array.isArray(value)) {
                    queryParams[key] = value.join(',');
                } else {
                    queryParams[key] = value;
                }
            }
        });

        return queryParams;
    }

    /**
     * Enhances activity item with proper data cleanup
     */
    private enhanceActivityItem(activity: ActivityItem): ActivityItem {
        return {
            ...activity,
            // Ensure timestamp is properly formatted
            timestamp: new Date(activity.timestamp).toISOString(),
            // Clean up entities
            entities: activity.entities?.map(entity => ({
                ...entity,
                displayName: entity.displayName?.trim() || 'Nieznany obiekt'
            }))
        };
    }

    /**
     * Checks if parameters include recent/today's data
     */
    private includesRecentData(params: ActivitySearchParams): boolean {
        const today = new Date().toISOString().split('T')[0];
        return !params.endDate || params.endDate >= today;
    }

    /**
     * Checks if date range includes current period
     */
    private isCurrentPeriod(startDate: string, endDate: string): boolean {
        const today = new Date().toISOString().split('T')[0];
        return endDate >= today;
    }

    /**
     * Checks if timestamp is from today
     */
    private isToday(timestamp: string): boolean {
        const today = new Date().toDateString();
        const activityDate = new Date(timestamp).toDateString();
        return today === activityDate;
    }

    /**
     * Checks if timestamp is recent (last 4 hours)
     */
    private isRecent(timestamp: string): boolean {
        const fourHoursAgo = new Date(Date.now() - 4 * 60 * 60 * 1000);
        return new Date(timestamp) > fourHoursAgo;
    }

    /**
     * Validates date format
     */
    private isValidDate(dateString: string): boolean {
        const regex = /^\d{4}-\d{2}-\d{2}$/;
        if (!regex.test(dateString)) return false;

        const date = new Date(dateString);
        return date instanceof Date && !isNaN(date.getTime());
    }

    /**
     * Cache management
     */
    private getCachedResult(key: string): any {
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data;
        }
        this.cache.delete(key);
        return null;
    }

    private setCachedResult(key: string, data: any): void {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }

    /**
     * Handles API errors consistently with Polish messages
     */
    private handleApiError(error: unknown, operation: string): ActivityApiResult {
        if (ApiError.isApiError(error)) {
            switch (error.status) {
                case 401:
                    return {
                        success: false,
                        error: 'Sesja wygas≈Ça. Zaloguj siƒô ponownie.',
                        details: error
                    };
                case 403:
                    return {
                        success: false,
                        error: 'Brak uprawnie≈Ñ do przeglƒÖdania aktywno≈õci.',
                        details: error
                    };
                case 404:
                    return {
                        success: false,
                        error: 'Nie znaleziono ≈ºƒÖdanych aktywno≈õci.',
                        details: error
                    };
                case 422:
                    return {
                        success: false,
                        error: error.data?.message || 'Nieprawid≈Çowe parametry wyszukiwania.',
                        details: error
                    };
                case 429:
                    return {
                        success: false,
                        error: 'Zbyt wiele ≈ºƒÖda≈Ñ. Spr√≥buj ponownie za chwilƒô.',
                        details: error
                    };
                case 500:
                    return {
                        success: false,
                        error: 'B≈ÇƒÖd serwera. Spr√≥buj ponownie p√≥≈∫niej.',
                        details: error
                    };
                case 503:
                    return {
                        success: false,
                        error: 'Serwis tymczasowo niedostƒôpny.',
                        details: error
                    };
                default:
                    return {
                        success: false,
                        error: error.data?.message || error.message || `B≈ÇƒÖd podczas ${operation}.`,
                        details: error
                    };
            }
        }

        if (error instanceof Error) {
            if (error.name === 'AbortError') {
                return {
                    success: false,
                    error: '≈ªƒÖdanie zosta≈Ço anulowane (przekroczono limit czasu).',
                    details: error
                };
            }
            if (error.message.includes('network') || error.message.includes('fetch')) {
                return {
                    success: false,
                    error: 'B≈ÇƒÖd po≈ÇƒÖczenia z serwerem.',
                    details: error
                };
            }
            return {
                success: false,
                error: error.message,
                details: error
            };
        }

        return {
            success: false,
            error: `WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd podczas ${operation}.`,
            details: error
        };
    }
}

// ========================================================================================
// EXPORTS
// ========================================================================================

// Export singleton instance
export const activityApi = new ActivityApi();

// Export for testing
export { ActivityApi };

// Default export
export default activityApi;